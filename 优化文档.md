## 代码优化

### 中间代码生成阶段的常数传播

非常简单的优化,中间代码生成的时候记录常量和常数的对应关系即可,翻译中间代码碰到常量就直接替换。

### 基本块建立

按照定义在中间代码分析阶段建立基本块，然后确立基本块之间的前驱后继关系，这个关系判断根据基本块的最后一句代码，如果最后一句是无条件跳转，则该基本块无法到达顺序的下一个基本块，不然都能到达下一个基本块，条件跳转则把对应基本块纳入后继，同时更新前驱基本块。

### 活跃变量分析

首先建立每个基本块内的 use 和 def 集合，然后根据基本块的前驱后继关系遍历每一个基本块，更新 in 或者 out集合，out 集合是所有后驱 in 集合的并集，in  = use + out - def。直到每一个 in 和 out 集合都没有变化。

### 寄存器图着色

遍历每一个基本块，倒着遍历。起始活跃遍历集合为out集合，接着倒着遍历每一个四元式，def和此时的活跃变量集合建立冲突，然后活跃变量集合减去该四元式对应的def，增加对应的use即可。

最后冲突图需要选择不重要的变量spill到内存里，对于变量权重，通过引用计数的思想，根据变量出现次数进行变量权重安排。

### 最短路

对于cond最短路,需要放弃Or和And运算,通过jump来空值,比如A | B,那么把前面半个认为是一个块,后面半个是一个块,A 块结尾无条件进入if,A块中四元式是为假跳转到B块,B块结尾无跳转语句,B块中四元式是为假跳转到else对应的基本块。

另外，如果已知为永真 or 永假，则省略部分四元式的翻译。